
# 📘 README — Autonomous AI Agent for Ruby Techfile Automation (Electronics Engineer Friendly)

---

## 🔹 1. Why We Need This

In chip design and semiconductor industries, you often have:

* Hundreds of **Ruby files** in a Linux folder, each describing **materials, metals, or layers**.
* A **techfile** must be generated (can be 11,000–12,000 lines long).
* If even one **metal definition is missing**, the techfile build fails.

👉 Instead of engineers manually hunting down missing files, we use an **AI agent** to:

1. Detect missing definitions.
2. Generate the missing Ruby files automatically.
3. Validate correctness.
4. Build a correct techfile.

---

## 🔹 2. What the Agent Will Do (Workflow in Simple Words)

Imagine the agent as a **robot assistant** in your Linux VM:

1. **Look around** the folder (scan all Ruby and text files).
2. **Take a handful** (5–10 files at a time → called a “chunk”).
3. **Ask the AI model**:

   * “Are any materials/metals missing here?”
   * If yes → generate the missing file(s).
   * If no → move to the next chunk.
4. **Make a safe copy** (backup) of any file before editing.
5. **Apply the changes** suggested by the AI.
6. **Check correctness**:

   * Run Ruby syntax check.
   * Run the internal script that builds the techfile.
7. **If it fails** → AI tries again (up to 3 retries).
8. **If it works** → Save results in a log file + keep the backup.

---

## 🔹 3. Workflow Flowchart

```
[Start]
   |
   v
[Scan all Ruby files in folder]
   |
   v
[Split into chunks of 5-10 files]
   |
   v
[For each chunk --> Send to AI model]
   |
   +----> [AI says "Nothing missing"] ---> [Move to next chunk]
   |
   +----> [AI finds "Missing metal"] ---> [Generate patch file]
                                               |
                                               v
                                   [Backup old file before editing]
                                               |
                                               v
                                    [Write new Ruby file(s) into folder]
                                               |
                                               v
                               [Run validator: ruby -c + techfile build]
                                               |
              +--------------------------------+--------------------------+
              |                                                               |
              v                                                               v
     [Validation PASSED]                                          [Validation FAILED]
              |                                                               |
              v                                                               v
 [Mark chunk completed, continue]                              [Retry (max 3 times)]
              |                                                               |
              v                                                               v
        [Final Techfile OK]                                       [Escalate to engineer]
              |
              v
             [End]
```

---

## 🔹 4. Step-by-Step Instructions (Linux Only, No GitHub)

### Step 1 — Prepare Environment

Run these once inside your VM:

```bash
# Create work directories
mkdir -p /opt/ai-agent/repo
mkdir -p /opt/ai-agent/backups
mkdir -p /opt/ai-agent/logs

# Ensure Ruby is installed
ruby -v

# Optional: Install linter
gem install rubocop
```

Place your **Ruby + text files** into `/opt/ai-agent/repo/`.

---

### Step 2 — Scanning and Chunking

The agent will:

* **Scan** all `.rb` files.
* Group them into **chunks of 5–10 files**.

Example Linux command to list Ruby files:

```bash
cd /opt/ai-agent/repo
find . -name "*.rb"
```

---

### Step 3 — AI Model Processing

* Send each chunk to the **AI model (Qwen3-Coder, Mistral, DeepSeek, etc.)**.
* The model checks for missing metal/material definitions.
* If missing → it generates new Ruby files like:

```ruby
# materials/metal_m3.rb
Material.define :M3 do
  name "Metal 3"
  layer :m3
  thickness_um 0.5
  conductivity 1.2
  description "Auto-generated by AI"
end
```

---

### Step 4 — Safe File Updates

Before writing any changes:

```bash
cp path/to/file.rb /opt/ai-agent/backups/file.rb.bak
```

Then replace with AI-generated file.

---

### Step 5 — Validation

Run checks:

```bash
# Syntax check
ruby -c path/to/modified.rb

# Full repo check
find . -name "*.rb" -exec ruby -c {} \;

# Try to build techfile
./generate_techfile.sh --output /opt/ai-agent/logs/techfile.out
```

If error → AI retries up to 3 times.

If still failing → stop and engineer checks logs in `/opt/ai-agent/logs/`.

---

### Step 6 — Logs & Rollback

All logs go into:

```
/opt/ai-agent/logs/run-YYYYMMDD-HHMM.log
```

If something goes wrong:

```bash
cp /opt/ai-agent/backups/file.rb.bak /opt/ai-agent/repo/file.rb
```

---

## 🔹 5. Handling **If–Else Scenarios** (Error Handling)

* **If AI output is invalid JSON →** discard, retry once.
* **If file already exists →** create a backup first.
* **If syntax check fails →** rollback file, retry AI fix.
* **If techfile build fails →** retry up to 3 times.
* **If all retries fail →** stop, alert engineer.
* **If validation passes →** accept file, mark success.

---

## 🔹 6. Fine-Tuning an Open-Source AI Model (For Electronics Engineers)

If you want to train your **own AI model** (e.g., Mistral, DeepSeek, LLaMA, etc.), here’s the **plain-English process**:

### Step 1 — Collect Data

* Gather **Ruby files + techfiles** from past projects.
* Also collect **examples of mistakes and their fixes** (before + after).
* Store them in folders like:

  ```
  dataset/
    correct_examples/
    incorrect_examples/
    fixes/
  ```

---

### Step 2 — Clean and Label

* Remove sensitive info (company secrets).
* Create **input → output pairs**:

  * Input: broken Ruby files.
  * Output: fixed Ruby files or patches.

Store in JSONL format (one example per line):

```json
{"input": "File missing METAL_M3", "output": "Add file metal_m3.rb with correct Material.define block"}
```

---

### Step 3 — Choose a Base Model

Pick an **open-source code model**:

* **Mistral** (good balance, 7B or 8x7B).
* **DeepSeek Coder** (powerful, optimized for code).
* **Qwen Coder** (already specialized for code repos).

---

### Step 4 — Fine-Tuning Process

Run inside Linux with GPUs:

1. **Install framework**:

   ```bash
   pip install transformers datasets peft
   ```
2. **Prepare dataset** (JSONL).
3. **Run LoRA fine-tuning** (parameter-efficient training). Example command:

   ```bash
   python train.py \
       --model mistral-7b \
       --data dataset/ \
       --output fine_tuned_model/
   ```
4. After training, test with your repo files.

---

### Step 5 — Deployment

* Copy fine-tuned model into VM.
* Replace calls to Qwen with your fine-tuned model.
* Same workflow applies: chunk files → detect → patch → validate.

---

## 🔹 7. Key Notes for Electronics Engineers

* Think of AI as a **junior engineer**: it suggests fixes, but you always keep backups.
* The **agent is not GitHub** → it only edits local Linux files.
* Validation (syntax + build) is **your safety net**.
* Fine-tuning makes the AI **better at your company’s specific style** of Ruby files and techfiles.

---
