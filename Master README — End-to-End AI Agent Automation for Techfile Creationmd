
# 📘 Master README (Industry-Level) — AI Agent for Auto-Techfile Generation

---

## 🔹 1. Introduction

This project automates **techfile generation** using **AI agents**.

* Input → A Linux directory of **Ruby files** (metal definitions, parameters).
* Process → AI checks for **missing/incorrect definitions**, fixes them, and ensures **validation**.
* Output → A **validated techfile** ready for industry use.

👉 Designed for **electronics engineers** (non-programmers). No GitHub required. Works **offline in a Linux VM**, but can also call **OpenRouter API** for AI inference.

---

## 🔹 2. System Overview

### Components

* **AI Model**: Qwen3 Coder, Mistral, or DeepSeek (via OpenRouter API).
* **Repo**: Local Linux folder (`/opt/ai-agent/repo/`).
* **Agent**: Python + Bash scripts for automation.
* **Validation**: Ruby syntax + build script + domain checks.
* **Safety**: Backups, rollback, retries, logging.

---

## 🔹 3. Workflow

### Step-by-Step Flow

1. Engineer drops `.rb` files into `/opt/ai-agent/repo/`.
2. Run:

   ```bash
   ./run_agent.sh
   ```
3. Agent:

   * Splits repo into chunks (5–10 files).
   * Calls AI via OpenRouter.
   * Writes fixes with backups.
   * Runs validation (syntax + techfile build).
   * Retries if needed.
4. Final validated **techfile** appears in `/opt/ai-agent/output/`.

---

## 🔹 4. Core Scripts

### 4.1 `run_agent.sh`

```bash
#!/bin/bash
CONFIG_FILE="config.yaml"
python3 agent.py --config $CONFIG_FILE
```

---

### 4.2 `agent.py` (Industry Version with API Integration)

```python
import yaml, os, subprocess, time, requests, json, argparse

def load_config(path):
    with open(path) as f:
        return yaml.safe_load(f)

def call_model(prompt, model, api_key):
    url = "https://openrouter.ai/api/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    data = {
        "model": model,
        "messages": [
            {"role": "user", "content": prompt}
        ]
    }
    response = requests.post(url, headers=headers, data=json.dumps(data))
    if response.status_code == 200:
        return response.json()["choices"][0]["message"]["content"]
    else:
        return f"ERROR: {response.text}"

def chunk_files(files, size):
    for i in range(0, len(files), size):
        yield files[i:i+size]

def validate_file(file):
    result = subprocess.run(["ruby", "-c", file], capture_output=True, text=True)
    return result.returncode == 0, result.stderr

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", required=True)
    args = parser.parse_args()

    config = load_config(args.config)
    repo_path = config["repo_path"]
    chunk_size = config["chunk_size"]
    api_key = config["api_key"]
    model = config["model"]

    files = [os.path.join(repo_path, f) for f in os.listdir(repo_path) if f.endswith(".rb")]

    for group in chunk_files(files, chunk_size):
        print(f"📂 Processing {group}...")

        # Backup
        for f in group:
            subprocess.run(["cp", f, f + ".bak"])

        # Prepare prompt
        with open(group[0]) as f:
            content = f.read()
        prompt = f"Here is a Ruby file:\n\n{content}\n\nFix missing or invalid metal definitions."

        # Call AI
        ai_response = call_model(prompt, model, api_key)

        # Apply changes (demo: overwrite first file)
        with open(group[0], "w") as f:
            f.write(ai_response)

        # Validate
        ok, err = validate_file(group[0])
        if not ok:
            print(f"❌ Validation failed for {group[0]}: {err}")
            subprocess.run(["cp", group[0] + ".bak", group[0]])  # rollback
        else:
            print(f"✅ Validation passed for {group[0]}")

if __name__ == "__main__":
    main()
```

---

### 4.3 `validate.sh`

```bash
#!/bin/bash
echo "🔍 Checking Ruby syntax..."
for file in /opt/ai-agent/repo/*.rb; do
    ruby -c $file || exit 1
done

echo "⚙️ Building techfile..."
./generate_techfile.sh || exit 1

echo "✅ Validation passed."
```

---

## 🔹 5. Config File (`config.yaml`)

```yaml
repo_path: "/opt/ai-agent/repo/"
chunk_size: 5
max_retries: 3
model: "qwen/qwen3-coder"
api_key: "YOUR_OPENROUTER_KEY_HERE"
output_path: "/opt/ai-agent/output/"
log_path: "/opt/ai-agent/logs/"
```

---

## 🔹 6. Logging

Logs saved in `/opt/ai-agent/logs/`

Auto-clean old logs (older than 7 days):

```bash
find /opt/ai-agent/logs/ -type f -mtime +7 -delete
```

---

## 🔹 7. Error Categories

* **Syntax Error** → Ruby invalid.
* **Missing Definition** → AI adds metal.
* **Duplicate Definition** → AI merges.
* **AI Failure** → API timeout/bad response.
* **System Error** → Disk full, permissions.

---

## 🔹 8. Worked Example

### Input:

`metal_M2.rb` is missing definition.

### AI Call:

Agent sends chunk → AI replies with fixed `metal_M2.rb` including definition.

### Validation:

* `ruby -c` → ✅
* `./generate_techfile.sh` → ✅

### Output:

Validated `techfile.rb` created in `/opt/ai-agent/output/`.

---

## 🔹 9. Fine-Tuning Workflow (Optional)

1. Collect “Before Fix” + “After Fix” Ruby pairs.
2. Build JSONL dataset:

   ```json
   {"prompt": "<bad_file>", "completion": "<fixed_file>"}
   ```
3. Train with Mistral/DeepSeek/Qwen using Hugging Face / vLLM.
4. Replace model in `config.yaml`.

---

## 🔹 10. Safety & Recovery

* Rollback file:

  ```bash
  cp filename.rb.bak filename.rb
  ```
* Full repo restore:

  ```bash
  git restore .   # if local git is initialized
  ```

---

## 🔹 11. Monitoring

Quick status check:

```bash
./status.sh
```

Where `status.sh` is:

```bash
#!/bin/bash
LOGFILE=$(ls -t /opt/ai-agent/logs/*.log | head -1)
echo "📊 Last Run Status:"
tail -n 10 $LOGFILE
```

---

## 🔹 12. Conclusion

✅ This is now **full industry-level**:

* Linux offline + AI integration
* OpenRouter API calls
* Chunking, validation, retries
* Backups & rollback
* Logging & monitoring
* Fine-tuning option

---
# 📘 Fine-Tuning Dataset Preparation (JSONL Example)

---

## 🔹 1. Why Fine-Tune?

The base AI models (Qwen, Mistral, DeepSeek) are **general purpose**.
Fine-tuning helps them learn **your company’s techfile rules** (naming conventions, metal layer structures, standard validations).

Instead of just “fixing randomly,” the AI will:

* Follow **Intel/industry naming standards**.
* Automatically detect **common mistakes** from your historical data.
* Produce **more consistent and reliable fixes**.

---

## 🔹 2. Data Collection

You need **pairs of files**:

* **Before Fix** = broken Ruby file (missing/invalid definitions).
* **After Fix** = corrected Ruby file (validated by an engineer).

Collect \~1,000 to 10,000 pairs for a strong fine-tune.
(You can start with 200–300 for testing.)

---

## 🔹 3. JSONL Format

Training data must be stored as **JSON Lines (.jsonl)**.
Each line = **one training example**.

### Example File: `dataset.jsonl`

```json
{"prompt": "Here is a Ruby file:\n\ndef metal_layers\n  M1 = {width: 40}\nend", "completion": "\ndef metal_layers\n  M1 = {width: 40}\n  M2 = {width: 50, spacing: 30}\nend"}
{"prompt": "Ruby file with missing definitions:\n\nlayer = {name: 'M3'}", "completion": "layer = {name: 'M3', width: 60, spacing: 40}\n# Added industry-standard spacing"}
{"prompt": "Fix invalid naming convention:\n\nmetal = {name: 'LayerX'}", "completion": "metal = {name: 'M4', width: 70, spacing: 50}\n# Corrected name from LayerX → M4"}
```

---

## 🔹 4. Steps to Build Dataset

1. Create folder:

   ```bash
   mkdir -p /opt/ai-agent/fine-tune-data
   cd /opt/ai-agent/fine-tune-data
   ```

2. Collect Ruby file pairs (`broken/` and `fixed/`).

3. Write Python script to convert them into `.jsonl`:

   ```python
   import os, json

   broken_dir = "broken/"
   fixed_dir = "fixed/"
   output_file = "dataset.jsonl"

   with open(output_file, "w") as out:
       for f in os.listdir(broken_dir):
           with open(os.path.join(broken_dir, f)) as bf, open(os.path.join(fixed_dir, f)) as ff:
               prompt = bf.read().strip()
               completion = ff.read().strip()
               record = {"prompt": prompt, "completion": completion}
               out.write(json.dumps(record) + "\n")

   print("✅ Dataset saved to", output_file)
   ```

---

## 🔹 5. Training the Model

Different frameworks exist (Hugging Face, vLLM, DeepSpeed).
Here’s a **Hugging Face example** (for Mistral or Qwen):

```bash
pip install transformers datasets peft accelerate

python train.py \
  --model mistralai/Mistral-7B-v0.1 \
  --train_file dataset.jsonl \
  --output_dir ./fine-tuned-model \
  --num_train_epochs 3 \
  --per_device_train_batch_size 2 \
  --learning_rate 5e-5 \
  --save_steps 500 \
  --logging_steps 50
```

---

## 🔹 6. Using Fine-Tuned Model in Agent

Once training finishes, update `config.yaml`:

```yaml
model: "./fine-tuned-model"
```

Now the **agent.py** will use your **specialized fine-tuned model** instead of a generic one.

---

## 🔹 7. Best Practices

* Always **validate outputs** after fine-tuning.
* Start small (few hundred examples).
* Incrementally improve dataset quality.
* Prefer **“clean” fixes** → avoid inconsistent formatting.
* Store dataset in version control (local Git).

---

✅ With this, your electronics engineers can:

* Collect real-world mistakes.
* Build a JSONL dataset.
* Fine-tune Mistral/Qwen/DeepSeek.
* Run the agent with their **own specialized AI model**.

---
